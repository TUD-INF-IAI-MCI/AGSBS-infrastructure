# This is free software, licensed under the LGPL v3. See the file "COPYING" for
# details.
#
# (c) 2015 Sebastian Humenda <shumenda |at| gmx |dot| de>
"""Common datastructures."""

import enum
import os
import sys
import re
from .errors import WrongFileNameError
from . import config

def path2chapter(string):
    """Convert a file name similar to as k010508.md, anh__.md or v__ to a tuple
of the corresponding chapter numbers.
Important: this function throws OsErrors which must be caught by the plugin /
frontend used; the supplied message can be displayed to the user."""
    old_fn = string[:] # back up file name for usage in error case
    string = os.path.split( string )[-1] # just take the file name
    if(string.endswith('.md')): string = string[:-3]
    else:
        raise WrongFileNameError('Not a supported file ending, must be .md.')

    found = False
    for prefix in config.VALID_FILE_BGN:
        if string.startswith(prefix):
            string = string[len(prefix):]
            found = True
    if not found:
        raise WrongFileNameError( "Wrong file name: got \"%s\", " % old_fn +\
                    "\not a valid chapter/paper prefix." )
    try:
        return int( string )
    except ValueError:
        raise WrongFileNameError( "Tried to convert %s to a " % string +\
                " number, looking at file %s." % old_fn )

def gen_id(text):
    """gen_id(text) -> an text for generating links.
This function tries to generate the same text's as pandoc."""
    text = text.lower()
    res_id = ''
    for char in text:
        if(char == ' '):
            res_id += '-'
        elif(char.isalpha() or char.isdigit()):
            res_id += char
        elif(char in ['.','_', '-']):
            res_id += char
        else:
            continue
    # strip hyphens at the beginning
    while(res_id.startswith('-')):
        res_id = res_id[1:]
    return res_id


def is_list_alike(obj):
    """Check whether object is iterable and supports indexing."""
    a = hasattr(obj, '__iter__')
    b = hasattr(obj, '__getitem__')
    return a and b

def get_encoding():
    """Return encoding for stdin/stdout."""
    encoding = sys.getdefaultencoding() # fallback
    if hasattr(sys.stdout, encoding) and sys.stdout.encoding:
        encoding = sys.stdout.encoding
    return encoding

def decode(input):
    """Safe version to decode data from subprocesses."""
    if not isinstance(input, bytes):
        raise TypeError("Only inputs are supported here.")
    return input.decode(get_encoding())



class Heading():
    """heading(text, level)

This class represents a heading to ease the handling of headings.

For specifying the type of a heading, Heading.Type is used, which is an enum.
"""
    class Type(enum.Enum):
        NORMAL = 0 # most headings are of that type
        APPENDIX = 1
        PREFACE = 2
    def __init__(self, text, level):
        self.__line_number = None
        self.__text = text
        self.__id = gen_id(text)
        self.__level = level
        self.__chapter_number = None
        self.__type = Heading.Type.NORMAL
        self.__chapter_number = None


    def get_chapter_number(self):
        return self.__chapter_number

    def set_chapter_number(self, num):
        self.__chapter_number = num

    def get_level(self):
        return self.__level

    def get_type(self):
        """Return of which Heading.Type this heading is."""
        return self.__type

    def set_type(self, a_type):
        if not isinstance(a_type, Heading.Type):
            raise ValueError("Wrong heading type. Must be of type Heading.Type.")
        else:
            self.__type = a_type

    def get_id(self):
        """Return the id as generated by Pandoc (also called label in other
                contextes) which serves as an anchor to this link."""
        return self.__id

    def get_text(self):
        return self.__text

    def set_line_number(self, lnum):
        """Set the line number, e.g. if heading was taken from a file."""
        self.__line_number = lnum

    def get_line_number(self):
        return self.__line_number


class FileHeading(Heading):
    """Heading which extracts chapter number and heading type from given file
    name. File name may not be a path but only the file name"""
    CHAPTERNUM = re.compile(r'^[a-z|A-Z]+(\d\d).*\.md')
    def __init__(self, text, level, file_name):
        super().__init__(text, level)
        self.__file_name = file_name
        def startswith(string, lst): # does str starts with one item of list?
            for token in lst:
                if string.startswith(token):
                    return True
            return False

        if startswith(file_name, config.VALID_MAIN_BGN):
            self.__type = Heading.Type.NORMAL
        elif startswith(file_name, config.VALID_PREFACE_BGN):
            self.__type = Heading.Type.PREFACE
        elif startswith(file_name, config.VALID_APPENDIX_BGN):
            self.__type = Heading.Type.APPENDIX
        else:
            raise ValueError("Couldn't extract heading type from '{}'". \
                    format(file_name))

        # strip all letters before chapter number
        match = FileHeading.CHAPTERNUM.search(file_name)
        if not match:
            raise ValueError('Could not extract chapter number from "%s".' %
                file_name)
        self.set_chapter_number(int(match.groups()[0]))

