# This is free software, licensed under the LGPL v3. See the file "COPYING" for
# details.
#
# (c) 2016 Sebastian Humenda <shumenda |at| gmx |dot| de>
"""Common datastructures."""

import enum
import os
import sys
import re
from . import errors
from . import common

def path2chapter(path):
    """Convert a file name similar to as k010508.md, anh__.md or v__ to a tuple
of the corresponding chapter numbers.
Important: this function throws OsErrors which must be caught by the plugin /
frontend used; the supplied message can be displayed to the user."""
    file_name = os.path.split(path)[-1]
    if file_name.endswith('.md'): file_name = file_name[:-3]
    else:
        raise errors.StructuralError('unsupported file ending {}, md expected'.\
                format(file_name[file_name.rfind('.')+1:]), path)

    found = False
    for prefix in common.VALID_FILE_BGN:
        if file_name.startswith(prefix):
            file_name = file_name[len(prefix):]
            found = True
    if not found:
        raise errors.StructuralError("file has invalid format, expected a known " +
                "prefix and a two-digit number in the file name", path)
    try:
        return int(file_name)
    except ValueError:
        raise errors.StructuralError(('unable to extract chapter number from file '
                         'name, invalid part of name is ' + file_name), path)

def gen_id(text):
    """gen_id(text) -> an text for generating links.
This function tries to generate the same text's as pandoc."""
    allowed_characters = ['.', '-', '_']
    text = text.lower()
    res_id = [] # does not contain double dash
    last_processed_char = ''
    for char in text:
        # insert hyphen if it is space AND last char was not a space
        if char.isspace() and not last_processed_char.isspace():
            res_id.append('-')
        elif char.isalpha() or char.isdigit() or char in allowed_characters:
            res_id.append(char)
        else:
            continue
        # the else case explicitely does not count as processed char (all those
        # which are going to be ignored)
        last_processed_char = char
    # strip hyphens at the beginning, as well as numbers
    while res_id and not res_id[0].isalpha():
        res_id.pop(0)
    return ''.join(res_id)


def get_encoding():
    """Return encoding for stdin/stdout."""
    encoding = sys.getdefaultencoding() # fallback
    if hasattr(sys.stdout, encoding) and sys.stdout.encoding:
        encoding = sys.stdout.encoding
    return encoding

def decode(input):
    """Safe version to decode data from subprocesses."""
    if not isinstance(input, bytes):
        return input
    else:
        encodings = [get_encoding()]
        # add some more:
        import locale
        if not locale.getdefaultlocale()[1] in encodings:
            encodings.insert(0, locale.getdefaultlocale()[1])
        output = None
        while encodings and not output:
            encoding = encodings.pop()
            try:
                output = input.decode(encoding)
            except UnicodeDecodeError:
                pass
        if not output:
            output = input.decode("utf-8", errors='ignore')
        return output



class Heading():
    """heading(text, level)

This class represents a heading to ease the handling of headings.

For specifying the type of a heading, Heading.Type is used, which is an enum.
"""
    class Type(enum.Enum):
        NORMAL = 0 # most headings are of that type
        APPENDIX = 1
        PREFACE = 2
    def __init__(self, text, level):
        self.__line_number = None
        self.__text = text
        self.__id = gen_id(text)
        self.__level = level
        self.__chapter_number = None
        self.__type = Heading.Type.NORMAL
        self.__chapter_number = None


    def get_chapter_number(self):
        return self.__chapter_number

    def set_chapter_number(self, num):
        if not isinstance(num, int):
            raise TypeError("Integer expected.")
        self.__chapter_number = num

    def get_level(self):
        return self.__level

    def get_type(self):
        """Return of which Heading.Type this heading is."""
        return self.__type

    def set_type(self, a_type):
        if not isinstance(a_type, Heading.Type):
            raise ValueError("Wrong heading type. Must be of type Heading.Type.")
        else:
            self.__type = a_type

    def get_id(self):
        """Return the id as generated by Pandoc (also called label in other
                contextes) which serves as an anchor to this link."""
        return self.__id

    def set_text(self, text):
        if not text:
            raise ValueError("Heading must have text.")
        self.__text = text

    def get_text(self):
        return self.__text

    def set_line_number(self, lnum):
        """Set the line number, e.g. if heading was taken from a file."""
        self.__line_number = lnum

    def get_line_number(self):
        return self.__line_number


class FileHeading(Heading):
    """Heading which extracts chapter number and heading type from given file
    name. File name may not be a path but only the file name"""
    CHAPTERNUM = re.compile(r'^[a-z|A-Z]+(\d\d).*\.md')
    def __init__(self, text, level, file_name):
        super().__init__(text, level)
        self.__file_name = file_name
        def startswith(string, lst): # does str starts with one item of list?
            for token in lst:
                if string.startswith(token):
                    return True
            return False

        if startswith(file_name, common.VALID_MAIN_BGN):
            super().set_type(Heading.Type.NORMAL)
        elif startswith(file_name, common.VALID_PREFACE_BGN):
            self.__type = Heading.Type.PREFACE
        elif startswith(file_name, common.VALID_APPENDIX_BGN):
            super().set_type(Heading.Type.APPENDIX)
        else:
            raise ValueError("Couldn't extract heading type from '{}'". \
                    format(file_name))

        # strip all letters before chapter number
        match = FileHeading.CHAPTERNUM.search(file_name)
        if not match:
            raise ValueError('Could not extract chapter number from "%s".' %
                file_name)
        self.set_chapter_number(int(match.groups()[0]))

class FileCache:
    """FileCache(files)

    The file cache stores files and their directory of a lecture root. It is
    assumed that `files` look like a list returned by os.walk() and starts in
    the lecture root. The cache sorts the files and groups them into preface,
    appendix and main chapters. Files not ending on `.md` are ignored.

    Example:

    >>> FileCache(os.walk('/path/to/some/lecture/root'))
    >>> f.get_neighbours_for('k01/k01.md') # might return
    [(v01', 'v01.md'), ('k02', 'k02.md')]
    >>> 'k01/k01.md' in f
    True
    """
    CHAPTER_PREFIX = re.compile(r'^([A-Z|a-z]+)\d+.*')
    def __init__(self, file_list):
        # initialize three "caches" for the file names
        self.__main, self.__preface, self.__appendix = [], [], []
        self.__presort(file_list)

    def __presort(self, file_list):
        """Presort chapters into preface, main and appendix."""
        for directory, _, files in file_list:
            relative_dirname = os.path.split(directory)[1]
            for file in files:
                if not file.endswith('.md'):
                    continue
                prefix = self.CHAPTER_PREFIX.search(file)
                if not prefix:
                    raise errors.StructuralError(("The file must be in the "
                        "following format: <chapter_prefix><chapter_number>.md"),
                        os.path.join(directory, file))
                prefix = prefix.groups()[0]
                if prefix in common.VALID_PREFACE_BGN:
                    self.__preface.append((relative_dirname, file))
                elif prefix in common.VALID_MAIN_BGN:
                    self.__main.append((relative_dirname, file))
                elif prefix in common.VALID_APPENDIX_BGN:
                    self.__appendix.append((relative_dirname, file))
                else:
                    raise errors.StructuralError(("The chapter prefix %s is "
                        "unknown") % prefix, os.path.join(directory, file))
        self.__preface.sort()
        self.__main.sort()
        self.__appendix.sort()

    def __contains__(self, file):
        """Return whether a given file is contained in the cache."""
        fns = lambda x: [dir_and_file[1] for dir_and_file in x]
        return os.path.split(file)[1] in (fns(self.__main) + fns(self.__preface)
                + fns(self.__appendix))

    def get_neighbours_for(self, path):
        """Return neighbours of a given chapter. Path can be absolute (file
        system) or relative to the lecture root.
        Example:
            >>> x.get_neighbours_for('/foo/bar/k03/k03.md')
            ('k02/k02.md', None) # has no next chapter
            """
        directory, file_name = os.path.split(os.path.abspath(path))
        _, directory = os.path.split(directory)
        file_path = (directory, file_name)
        files = self.__preface + self.__main + self.__appendix
        for index, other_path in enumerate(files):
            if file_path == other_path:
                previous = (files[index-1] if index > 0 else None)
                next = (files[index+1] if (index+1) < len(files) else None)
                return (previous, next)
        # if this code fragment is reached, file was not contained in list
        raise errors.StructuralError(("The file was not found in the lecture. "
            "This indicates a bug."), path)


